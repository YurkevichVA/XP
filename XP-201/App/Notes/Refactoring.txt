Рефакторінг - внесення змін у код, які не змінюють функціональність (поведінку) коду.
Можна вважати поліморфізмом, так як зміни відбуваються із постійною алгоритмічною суттю.
Якщо зміни вносяться в алгоритм роботи, то це не рефакторинг.
Мета: знайти найбільш оптимальну форму вираження коду.
    for(i:1..10) print(i)
    while(i<10) print(i++)
    do print(i++) while(i<10)
    рекурсія
    range(10).forEach(print)
    print(range(10).join(','))
    print(1),print(2),...print(10)
    print("1,2,3...10")
питання оптимальності є відкритим, тобто перед рефакторингом слід це питання вирішити
У XP це - простота (Simple design) - зрозумілість (всередині команди). (+ стандарти кодування, + метафора системи)

Основні прийоми рефакторингу
Можна виділити окремі прийоми, але 
    - не всі можливості рефакторингу будуть реалізовані (перебрані)
    - багато прийомів мають протилежні значення (перенесення поля до батька/до нащадка)
    - прийом прадигмо-орієнтовані (сильно залежать від парадигми, частіше - ООП)

Боротьба з антипатернами
    - "Магічне число" - поява у коді числа (окрім 0 та 1), сенс якого незрозумілий
       (або неочевидний)                який сенс?
       int getRating() {
            return numberOfLateDeliveries > 5 ? 2 :1;
       }
    - "Магічний рядок" - те ж саме, але рядком, різновид "Hardcoded string"
        if(login == "admin") { - "Магічний рядок"
            print("Hello") - Hardcoded string
        }
    - Це ж стосується і кольорів, поява імені чи коду кольору теж можна віднести до цих антипатернів

Можливі рішення:
    - "Магічне число":
        = Enum
            + для обмежених переліків: рейтинг
            - для неперервних даних: кількість протермінованих замовлень
        = константи
            + іменування, розкриття сенсу (через ім'я)
            - зміни вимагають перекомпіляції
        = Функція/метод
            + можливе для складних алгоритмів обчислення
        = Конфігурація (в окремому файлі)
            + можливість змін без перекомпіляції
            - можливість втрат через видалення файлу
        = Провайдери-інжектори (інжекція залежностей)
            + рекомендований підхід в ООП
            - ускладнення архітектури (додавання інжекторів)
        = Ресурси (окремі файли, які автоматично підключаються системою в залежності від умов/оточення запуску програми - ОС, мова, роздільна здатність, розмір/орієнтація екрану тощо)
            + автоматичні зміни, підходить для "Hardcoded string"
            - потреба різних ресурсів для різних умов оточення

Проблема: "роздутий" код (метод, клас, файл тощо)
Ознака(критерій): окремий блок коду можна поєднати своїм коментарем

class{
  method{
    instruction              |
    instruction      | algo      |
    instruction      | for      |  region
    instruction      | smthn      |  for
    instruction      |        |  smthn
    instruction              |
  }                    |
  method{                  |
    instruction              |
    instruction              |
    instruction              |
  }                    |
  method{
    instruction
    instruction
    instruction
  }
}

Альтернативні критерії: блок коду (метод, клас, файл) 
не влазить на один "екран" (25-40 рядків)

Критика: занадто розгалужений код, для розуміння цілісної картини
необхідно переглянути велику кількість файлів